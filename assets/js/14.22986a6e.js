(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{574:function(e,t,l){"use strict";l.r(t);var n=l(13),i=Object(n.a)({},(function(){var e=this,t=e.$createElement,l=e._self._c||t;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h3",{attrs:{id:"_0-5px怎么实现"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_0-5px怎么实现"}},[e._v("#")]),e._v(" 0.5px怎么实现")]),e._v(" "),l("ol",[l("li",[e._v("transform + scale")]),e._v(" "),l("li",[e._v("直接写 0.5 px 但是在不同的浏览器上面会有不同的显示结果")]),e._v(" "),l("li",[e._v("linear-gradient 渐变 linear-gradient(0deg, #fff, #000)")]),e._v(" "),l("li",[e._v("SVG")]),e._v(" "),l("li",[e._v("box-shadow 第二个参数")]),e._v(" "),l("li",[e._v("meta的 viewport"),l("br"),e._v(" "),l("meta",{attrs:{name:"viewport",content:"width=device-width,initial-sacle=1"}})])]),e._v(" "),l("ul",[l("li",[e._v("useState 维护状态")]),e._v(" "),l("li",[e._v("useEffect 完成副作用操作\n"),l("ul",[l("li",[e._v("可以替换成 componentDidMount，componentDidUpdate，componentWillUnmount")])])]),e._v(" "),l("li",[e._v("useContext 使用 共享状态\n"),l("ul",[l("li",[e._v("Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props")])])]),e._v(" "),l("li",[e._v("useReducer 类似 Redux")]),e._v(" "),l("li",[e._v("useCallback 缓存函数\n"),l("ul",[l("li",[e._v("react 中只要是父组件的 render 了，那么默认情况下就会触发子组件的 render，render提供了来避免这种重渲染的性能开销的一些方法，React.PureComponent、React.memo、shouldComponentUpdate")])])]),e._v(" "),l("li",[e._v("useMemo 缓存值")]),e._v(" "),l("li",[e._v("useRef 访问DOM")]),e._v(" "),l("li",[e._v("useImperativeHandle 使用子组件暴露的值/方法")]),e._v(" "),l("li",[e._v("useLayoutEffect 完成副作用操作，会诸塞浏览器的绘制\n"),l("ul",[l("li",[e._v("在所有的 DOM 变更之后同步调用 effect，可以使用它来读取DOM 布局并同步触发重渲染，在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新，也就是说他会阻塞浏览器绘制，所以尽可能使用useEffect 以避免阻塞视觉更新")])])])])])}),[],!1,null,null,null);t.default=i.exports}}]);