(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{583:function(e,t,n){"use strict";n.r(t);var o=n(13),l=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"react-hooks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks"}},[e._v("#")]),e._v(" React Hooks")]),e._v(" "),n("ul",[n("li",[e._v("useState 维护状态")]),e._v(" "),n("li",[e._v("useEffect 完成副作用操作\n"),n("ul",[n("li",[e._v("可以替换成 componentDidMount，componentDidUpdate，componentWillUnmount")])])]),e._v(" "),n("li",[e._v("useContext 使用 共享状态\n"),n("ul",[n("li",[e._v("Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props")])])]),e._v(" "),n("li",[e._v("useReducer 类似 Redux")]),e._v(" "),n("li",[e._v("useCallback 缓存函数\n"),n("ul",[n("li",[e._v("react 中只要是父组件的 render 了，那么默认情况下就会触发子组件的 render，render提供了来避免这种重渲染的性能开销的一些方法，React.PureComponent、React.memo、shouldComponentUpdate")])])]),e._v(" "),n("li",[e._v("useMemo 缓存值")]),e._v(" "),n("li",[e._v("useRef 访问DOM")]),e._v(" "),n("li",[e._v("useImperativeHandle 使用子组件暴露的值/方法")]),e._v(" "),n("li",[e._v("useLayoutEffect 完成副作用操作，会诸塞浏览器的绘制\n"),n("ul",[n("li",[e._v("在所有的 DOM 变更之后同步调用 effect，可以使用它来读取DOM 布局并同步触发重渲染，在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新，也就是说他会阻塞浏览器绘制，所以尽可能使用useEffect 以避免阻塞视觉更新")])])])])])}),[],!1,null,null,null);t.default=l.exports}}]);