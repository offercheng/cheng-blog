(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{584:function(e,t,o){"use strict";o.r(t);var n=o(13),l=Object(n.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h3",{attrs:{id:"react-生命周期"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#react-生命周期"}},[e._v("#")]),e._v(" React 生命周期")]),e._v(" "),o("ul",[o("li",[e._v("挂载卸载过程\n"),o("ul",[o("li",[e._v("constructor()\n"),o("ul",[o("li",[e._v("constructor() 中完成了React 数据的初始化，他接受两个参数：props和context，当项在函数内部使用这两个参数是，需要使用super() 传入这两个参数，")]),e._v(" "),o("li",[e._v("只要使用了constructor() 就必须写super() ，否则就会导致this指向错误")])])]),e._v(" "),o("li",[e._v("componentWillMount()\n"),o("ul",[o("li",[e._v("componentWillMount() 一般使用的比较少，它更多的是在服务端渲染的时候使用，它代表的过程是组件以及经历 constructor() 初始化数据后，但是还未渲染DOM 时。")])])]),e._v(" "),o("li",[e._v("componentDidMount()\n"),o("ul",[o("li",[e._v("组件第一次渲染完成，此时dom节点已经生产，可以在这里调用ajax请求，返回数据setState 后组件会重新渲染")])])]),e._v(" "),o("li",[e._v("componentWillUnmount()\n"),o("ul",[o("li",[e._v("在此处完成组件的卸载和数据的销毁")]),e._v(" "),o("li",[e._v("clear 你在组件中所有的 setTimeout，setInterval")]),e._v(" "),o("li",[e._v("移除所有的组件中监听的 removeEventListener")])])])])]),e._v(" "),o("li",[e._v("更新过程\n"),o("ul",[o("li",[e._v("componentWillReceiveProps(nextProps)\n"),o("ul",[o("li",[e._v("在接受父组件改变后的props需要重新渲染组件时用到的比较多")])])]),e._v(" "),o("li",[e._v("shouldComponentUpdate(nextProps,nextState)\n"),o("ul",[o("li",[e._v("主要用于性能优化(部分更新)")]),e._v(" "),o("li",[e._v("唯一用于控制组件重新渲染的生命周期，由于在 react中，setState以后，state 发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新，因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要将所有的子组件都跟着重新渲染的，因此需要在自组建的该声明周期做出判断")])])]),e._v(" "),o("li",[e._v("componentWillUpdate(nextProps,nextState)\n"),o("ul",[o("li",[e._v("shouldComponentUpdate 返回true 以后，组件进入重新渲染的流程，进入componentWillUpdate ，这里同样可以拿到参数")])])]),e._v(" "),o("li",[e._v("componentDidUpdate(prevProps,prevState)\n"),o("ul",[o("li",[e._v("组件更新完毕后，react只会在第一次初始化成功 componentDidmount，之后每一次重新渲染后都会进入到这个生命周期，这里可以拿到参数，更新前面的props和state")])])]),e._v(" "),o("li",[e._v("render()\n"),o("ul",[o("li",[e._v("render函数会插入到jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，再次react会通过其diff算法比较更新前后的新旧DOM树，比较后，找到最小的有差异的DOM节点，并重新渲染")])])])])]),e._v(" "),o("li",[e._v("React 新增的生命周期\n"),o("ul",[o("li",[e._v("getDerivedStateFromProps(nextProps,prevState)\n"),o("ul",[o("li",[e._v("代替componentWillReceiveProps()")]),e._v(" "),o("li",[e._v("老版本中的componentWillReceiveProps() 方法判断前后两个props是否相同，如果不同再将新的props更新到相应的state上去，这样做会破化state数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数")]),e._v(" "),o("li",[e._v("在componentWillReceiveProps中，我们一般会做以下两种事情，一是根据props来更新state，而是触发一些回调，如动画或页面跳转")]),e._v(" "),o("li",[e._v("在老版本的React 中，这两种事我们都需要在componentWillReceiveProps 中去做")]),e._v(" "),o("li",[e._v("而在新版本中，官方将更新state与触发回调分配到了getDerivedStateFromProps 与componDidUpdate中，是的组件整体的更新逻辑更为清晰，而且在getDerivedStateFromProps中还禁止组件去访问this.props，强制让开发者去比较nextProps，prevState中的值，以确保当开发者用到getDerivedStateFromProps这个生命周期函数时，就是再根据当前的props来更新组件的state，而不是去做其他一些让组件自身状态变得更加不可预测的事情")])])]),e._v(" "),o("li",[e._v("getSnapshotBeforeUpdate(prevProps,prevState)\n"),o("ul",[o("li",[e._v("代替componentWillUpdate")]),e._v(" "),o("li",[e._v("常见的 componentWillUpdate 的用例是在组件更新前，读取当前某个DOM元素的状态，并在componentDidUpdate中进行相应的处理")]),e._v(" "),o("li",[e._v("在React 开启异步渲染模式后，在render阶段读取到的DOM元素状态并不总和commit阶段相同，这就导致了componentDidUpdate中使用componentWillUpdate中读取到DOM元素状态不是安全的，因为这时的值很有可能已经失效了")]),e._v(" "),o("li",[e._v("getSnapshotBeforeUpdate 会在最终的render之前被调用，也就是说在getSnapshotBeforeUpdate中读取到的DOM元素的状态是可以保证与componentDidUpdate 中一致的，此声明周期返回的任何值都会将其作为参数传递给componentDidUpdate()")])])])])]),e._v(" "),o("li",[e._v("React 的生命周期从广义上面分为三个阶段：挂载、渲染、卸载")]),e._v(" "),o("li",[e._v("首先开始然后getDefaultProps，getInitialState，componentWillMount，render，componentDidMount，运行中，属性改变 componentWillReceiveProps，然后shouldComponentUpdate，状态改变就直接shouldComponentUpdate，componentWillUpdate，render，componentDidUpdate ，就接着运行，最后就是组件卸载 ComponentWillUnmount 就结束了")])])])}),[],!1,null,null,null);t.default=l.exports}}]);